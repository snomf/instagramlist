<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="favicon.png"> <!-- Make sure you have a favicon.png -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A simple tool to manage Instagram lists, track progress, handle exceptions, export/import state, and filter lists.">
    <meta name="author" content="cravemenn">
    <meta name="keywords" content="instagram, list manager, checklist, social media tool, export, import, filter">
    <title>Instagram List Manager</title>
    <style>
        :root {
            /* Light Mode Colors */
            --bg-color: #ffffff;
            --secondary-bg-color: #fafafa;
            --card-bg-color: #ffffff;
            --text-color: #262626;
            --secondary-text-color: #8e8e8e;
            --border-color: #dbdbdb;
            --link-color: #00376b;
            --link-hover-color: #00376b;
            --separator-color: #efefef;
            --checkbox-border: #c7c7c7;
            --checkbox-checked-bg: #0095f6;
            --button-bg: #0095f6;
            --button-text: #ffffff;
            --button-hover-bg: #007cc2;
            --button-secondary-bg: #efefef;
            --button-secondary-text: #262626;
            --button-secondary-hover-bg: #e0e0e0;
            --input-border: #dbdbdb;
            --input-bg: #fafafa;
            --star-color: #ffcc00;
            --star-default-color: #c7c7c7;
            --notification-bg-info: #e0f2ff;
            --notification-text-info: #005f99;
            --notification-bg-success: #e0fff0;
            --notification-text-success: #007a4d;
            --notification-bg-error: #ffe0e0;
            --notification-text-error: #a30000;
            --modal-overlay-bg: rgba(0, 0, 0, 0.5);
            --modal-bg: #ffffff;
            --modal-text: #262626;
            --modal-border: #dbdbdb;
            --icon-fill: #262626; /* For SVGs in controls */
            --header-icon-color: #8e8e8e; /* For Unicode header icons */
            --header-icon-hover-color: #262626;
            --filter-input-bg: #efefef;
            --filter-input-border: #dbdbdb;
            --filter-input-text: #262626;
        }

        /* Dark Mode Colors */
        body.dark-mode {
            --bg-color: #000000;
            --secondary-bg-color: #121212;
            --card-bg-color: #000000;
            --text-color: #f5f5f5;
            --secondary-text-color: #a8a8a8;
            --border-color: #363636;
            --link-color: #0095f6;
            --link-hover-color: #47afff;
            --separator-color: #262626;
            --checkbox-border: #555555;
            --checkbox-checked-bg: #0095f6;
            --button-bg: #0095f6;
            --button-text: #ffffff;
            --button-hover-bg: #007cc2;
            --button-secondary-bg: #262626;
            --button-secondary-text: #f5f5f5;
            --button-secondary-hover-bg: #3a3a3a;
            --input-border: #363636;
            --input-bg: #262626;
            --star-color: #ffd966;
            --star-default-color: #555555;
            --notification-bg-info: #003c66;
            --notification-text-info: #e0f2ff;
            --notification-bg-success: #004d33;
            --notification-text-success: #e0fff0;
            --notification-bg-error: #660000;
            --notification-text-error: #ffe0e0;
            --modal-overlay-bg: rgba(0, 0, 0, 0.7);
            --modal-bg: #1c1c1c;
            --modal-text: #f5f5f5;
            --modal-border: #363636;
            --icon-fill: #f5f5f5; /* For SVGs in controls */
            --header-icon-color: #a8a8a8; /* For Unicode header icons */
            --header-icon-hover-color: #f5f5f5;
             --filter-input-bg: #262626;
            --filter-input-border: #363636;
            --filter-input-text: #f5f5f5;
        }

        /* --- Base & Layout --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.5;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container {
            max-width: 700px;
            margin: 0 auto;
            padding: 15px;
            border-left: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
            min-height: 100vh;
            box-sizing: border-box;
        }
        header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px; margin-bottom: 15px;
        }
        h1 { font-size: 1.4em; font-weight: 600; margin: 0; color: var(--text-color); }
        h1 small { font-size: 0.6em; font-weight: 400; color: var(--secondary-text-color); }
        h1 small i { font-style: normal;}
        h1 small b a { color: var(--link-color); text-decoration: none; font-weight: 600;}
        h1 small b a:hover { text-decoration: underline; }


        /* --- Header Buttons (Now using Unicode) --- */
        header .header-buttons { display: flex; gap: 8px; /* Slightly more gap */ }
        header .header-buttons button {
            background: none; border: none; cursor: pointer;
            padding: 5px; line-height: 1;
            font-size: 1.4em; /* Adjust size for Unicode chars */
            color: var(--header-icon-color);
            transition: color 0.2s ease;
        }
        header .header-buttons button:hover { color: var(--header-icon-hover-color); }


        /* --- Controls Area --- */
        .controls {
            background-color: var(--secondary-bg-color);
            border: 1px solid var(--border-color); border-radius: 8px;
            padding: 15px; margin-bottom: 20px;
            display: flex; flex-direction: column; /* Stack sections vertically */
            gap: 20px; /* Space between sections */
        }
        .control-section { display: flex; flex-direction: column; gap: 8px; }
        .control-section label {
            font-weight: 600; font-size: 0.9em;
            color: var(--secondary-text-color);
        }
        .controls textarea, .controls input[type="text"] {
            width: 100%; padding: 8px 10px;
            border: 1px solid var(--input-border); border-radius: 4px;
            background-color: var(--input-bg); color: var(--text-color);
            font-size: 0.9em; box-sizing: border-box;
        }
        .controls textarea { min-height: 60px; resize: vertical; }
        .controls .button-group { display: flex; gap: 10px; flex-wrap: wrap; }

        /* --- Control Buttons (Using SVG) --- */
        .controls button {
            padding: 6px 10px;
            background-color: var(--button-secondary-bg);
            color: var(--button-secondary-text);
            border: 1px solid var(--border-color); border-radius: 6px;
            cursor: pointer; font-weight: 600;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
            font-size: 0.9em;
            line-height: 1;
            display: inline-flex; align-items: center; justify-content: center;
            gap: 5px; /* Space between icon and text */
        }
        .controls button:hover { background-color: var(--button-secondary-hover-bg); }
        .controls button svg {
            width: 16px; height: 16px;
            fill: currentColor; /* Use button's text color for SVG fill */
        }

        /* Primary action button */
        .controls button.primary-action {
            background-color: var(--button-bg); color: var(--button-text);
            border-color: var(--button-bg);
        }
        .controls button.primary-action:hover {
            background-color: var(--button-hover-bg); border-color: var(--button-hover-bg);
        }
        /* SVG fill for primary button uses currentColor which is var(--button-text) -> white */

        /* Restore input + button */
        .restore-section { display: flex; gap: 10px; align-items: center; }
        .restore-section input { flex-grow: 1; }
        .restore-section button { flex-shrink: 0; }

        /* --- Stats & Filter Area --- */
         .list-header {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 10px;
             flex-wrap: wrap;
             gap: 10px;
         }
        .stats {
            font-size: 0.9em;
             color: var(--secondary-text-color);
            text-align: left;
            margin: 0;
             flex-grow: 1;
        }
        .stats strong { color: var(--text-color); font-weight: 600; }
        .stats span { margin: 0 3px; }

         #filterInput {
             padding: 6px 10px;
             border: 1px solid var(--filter-input-border);
             border-radius: 6px;
             background-color: var(--filter-input-bg);
             color: var(--filter-input-text);
             font-size: 0.9em;
             width: 200px;
             box-sizing: border-box;
         }

        /* --- User List --- */
        ul#userList {
            list-style-type: none; padding: 0; margin: 0 0 20px 0;
            border: 1px solid var(--border-color); border-radius: 8px;
            overflow: hidden;
        }
         ul#userList:empty {
             border: 2px dashed var(--border-color); padding: 30px;
             text-align: center; color: var(--secondary-text-color);
             min-height: 50px; border-radius: 8px;
         }
         ul#userList:empty::before {
             content: "Import a list above to get started!";
             display: block;
         }

        li {
            background-color: var(--card-bg-color);
            border-bottom: 1px solid var(--separator-color);
            padding: 10px 15px; display: flex; align-items: center;
            gap: 12px; transition: background-color 0.3s ease, opacity 0.3s ease;
        }
        li:last-child { border-bottom: none; }
         li.hidden-by-filter { display: none; }

        /* List Item Elements */
        input[type="checkbox"] {
            appearance: none; -webkit-appearance: none; -moz-appearance: none;
            width: 18px; height: 18px; border: 1px solid var(--checkbox-border);
            border-radius: 4px; cursor: pointer; position: relative;
            background-color: var(--card-bg-color); flex-shrink: 0;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        input[type="checkbox"]:checked {
            background-color: var(--checkbox-checked-bg); border-color: var(--checkbox-checked-bg);
        }
        input[type="checkbox"]:checked::after {
            content: ''; position: absolute; top: 2px; left: 5px;
            width: 4px; height: 8px; border: solid white;
            border-width: 0 2px 2px 0; transform: rotate(45deg);
        }
        .star-btn {
            background: none; border: none; padding: 0 5px;
            cursor: pointer; flex-shrink: 0; line-height: 1;
        }
         .star-btn svg {
             width: 18px; height: 18px; fill: var(--star-default-color);
             transition: fill 0.2s ease;
         }
         li.starred-item .star-btn svg { fill: var(--star-color); }
        label {
             flex-grow: 1; margin: 0; overflow: hidden;
             text-overflow: ellipsis; white-space: nowrap; cursor: pointer;
        }
        a {
            color: var(--link-color); text-decoration: none;
            font-weight: 600; font-size: 0.95em;
            transition: color 0.2s ease;
        }
        a:hover { text-decoration: underline; color: var(--link-hover-color); }

        /* Item States */
        li.checked-item label a {
            text-decoration: line-through; color: var(--secondary-text-color); opacity: 0.7;
        }
        li.starred-item { opacity: 0.9; }

        /* --- Notification Bar --- */
        #notificationArea {
            position: fixed; top: -100px; left: 50%; transform: translateX(-50%);
            min-width: 250px; max-width: 80%; padding: 12px 20px;
            background-color: var(--notification-bg-info); color: var(--notification-text-info);
            border-radius: 0 0 8px 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            z-index: 1000; text-align: center; font-size: 0.95em;
            transition: top 0.4s ease-in-out, opacity 0.4s ease-in-out, background-color 0.3s, color 0.3s;
            opacity: 0;
        }
        #notificationArea.show { top: 0; opacity: 1; }
        #notificationArea.success { background-color: var(--notification-bg-success); color: var(--notification-text-success); }
        #notificationArea.error { background-color: var(--notification-bg-error); color: var(--notification-text-error); }

        /* --- Confirmation Modal --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--modal-overlay-bg);
            display: flex; align-items: center; justify-content: center;
            z-index: 1050; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s;
        }
        .modal-overlay.show { opacity: 1; visibility: visible; transition-delay: 0s; }
        .modal-content {
            background-color: var(--modal-bg); color: var(--modal-text);
            padding: 25px; border-radius: 8px;
            border: 1px solid var(--modal-border);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            max-width: 400px; width: 90%;
            transform: scale(0.9); opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .modal-overlay.show .modal-content { transform: scale(1); opacity: 1; }
        .modal-content p { margin: 0 0 20px 0; font-size: 1em; line-height: 1.5; }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 10px; }
        .modal-buttons button {
            padding: 8px 15px; border-radius: 6px; cursor: pointer;
            font-weight: 600; transition: background-color 0.2s ease;
            font-size: 0.9em; border: none;
        }
        .modal-confirm-btn { background-color: var(--button-bg); color: var(--button-text); }
        .modal-confirm-btn:hover { background-color: var(--button-hover-bg); }
        .modal-cancel-btn { background-color: var(--button-secondary-bg); color: var(--button-secondary-text); border: 1px solid var(--border-color); }
        .modal-cancel-btn:hover { background-color: var(--button-secondary-hover-bg); }

    </style>
</head>
<body>
    <!-- SVG Icons Definition -->
    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
        <!-- Removed #icon-reset and #icon-theme as they are replaced by Unicode -->
        <symbol id="icon-import" viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></symbol>
        <symbol id="icon-copy" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></symbol>
        <symbol id="icon-save" viewBox="0 0 24 24"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm2 16H5V5h11.17L19 7.83V19zm-7-7c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zM6 6h9v4H6z"/></symbol>
        <symbol id="icon-download" viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></symbol>
        <symbol id="icon-upload" viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/></symbol>
        <symbol id="icon-star-outline" viewBox="0 0 24 24"><path d="M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21zM12 15.4l3.76 2.27-.98-4.24 3.27-2.99-4.34-.38L12 6.23l-1.71 4.03-4.34.38 3.27 2.99-.98 4.24L12 15.4z"/></symbol>
        <symbol id="icon-star-filled" viewBox="0 0 24 24"><path d="M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></symbol>
        <symbol id="icon-clear" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></symbol> <!-- Added Clear Icon -->
    </svg>

    <div id="notificationArea"></div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal-overlay">
        <div class="modal-content">
            <p id="modalMessage">Confirm this action?</p>
            <div class="modal-buttons">
                <button id="modalCancelBtn" class="modal-cancel-btn">Cancel</button>
                <button id="modalConfirmBtn" class="modal-confirm-btn">Confirm</button>
            </div>
        </div>
    </div>

    <div class="container">
        <header>
             <h1> List Manager <small><i>by</i> <b> <a href="https://www.instagram.com/cravemenn" target="_blank">cravemenn</a></b></small></h1>
            <div class="header-buttons">
                 <!-- Use Unicode icons for header -->
                 <button id="clearAllBtn" title="Clear List & State">üóëÔ∏è</button> <!-- Changed to Trash Bin icon -->
                 <button id="darkModeToggle" title="Toggle Theme">üåì</button>
            </div>
        </header>

        <div class="controls">
             <div class="control-section">
                 <label for="importListInput">Import New List (comma-separated usernames):</label>
                 <textarea id="importListInput" rows="3" placeholder="user1, another_user, user_3,..."></textarea>
                 <div class="button-group">
                    <button id="importListBtn" class="primary-action">
                        <svg><use href="#icon-import"/></svg> Import List
                    </button>
                 </div>
            </div>

             <div class="control-section">
                <label>Copy / Restore Checked Users Only (Non-Starred):</label>
                <textarea id="checkedListOutput" readonly rows="2" placeholder="Checked (non-starred) usernames..."></textarea>
                <div class="button-group">
                    <button id="copyCheckedListBtn">
                        <svg><use href="#icon-copy"/></svg> Copy Checked
                    </button>
                    <div class="restore-section">
                        <input type="text" id="restoreCheckedListInput" placeholder="Paste list to restore checks...">
                        <button id="restoreCheckedListBtn">
                           <svg><use href="#icon-save"/></svg> Restore Checks
                        </button>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <label>Export / Import Full State (JSON - Includes Checked, Starred, Unchecked):</label>
                <textarea id="fullStateOutput" rows="3" placeholder="Full state data (JSON format)..."></textarea>
                 <div class="button-group">
                    <button id="exportFullStateBtn">
                        <svg><use href="#icon-download"/></svg> Export State (JSON)
                    </button>
                    <button id="importFullStateBtn">
                        <svg><use href="#icon-upload"/></svg> Import State (JSON)
                    </button>
                 </div>
            </div>
        </div>

        <div class="list-header">
            <div class="stats">
                Total: <strong id="totalUserCount">0</strong>
                <span>|</span>
                Checked: <strong id="checkedUserCount">0</strong>
                <span>|</span>
                Starred: <strong id="starredUserCount">0</strong>
                <span>|</span>
                Completion: <strong id="completionPercentage">0.0</strong>%
            </div>
             <input type="text" id="filterInput" placeholder="Filter list...">
        </div>


        <ul id="userList">
            <!-- List items are generated by JS -->
        </ul>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const userListEl = document.getElementById('userList');
            const totalUserCountEl = document.getElementById('totalUserCount');
            const checkedUserCountEl = document.getElementById('checkedUserCount');
            const starredUserCountEl = document.getElementById('starredUserCount');
            const completionPercentageEl = document.getElementById('completionPercentage');
            const copyCheckedListBtn = document.getElementById('copyCheckedListBtn');
            const checkedListOutput = document.getElementById('checkedListOutput');
            const restoreCheckedListInput = document.getElementById('restoreCheckedListInput');
            const restoreCheckedListBtn = document.getElementById('restoreCheckedListBtn');
            const importListInput = document.getElementById('importListInput');
            const importListBtn = document.getElementById('importListBtn');
            const darkModeToggle = document.getElementById('darkModeToggle');
            const clearAllBtn = document.getElementById('clearAllBtn');
            const exportFullStateBtn = document.getElementById('exportFullStateBtn');
            const importFullStateBtn = document.getElementById('importFullStateBtn');
            const fullStateOutput = document.getElementById('fullStateOutput');
            const filterInput = document.getElementById('filterInput');
            const notificationArea = document.getElementById('notificationArea');
            const confirmationModal = document.getElementById('confirmationModal');
            const modalMessage = document.getElementById('modalMessage');
            const modalConfirmBtn = document.getElementById('modalConfirmBtn');
            const modalCancelBtn = document.getElementById('modalCancelBtn');
            const body = document.body;

            // --- State & Constants ---
            const CHECKED_USERS_KEY = 'listManagerCheckedUsersV2';
            const STARRED_USERS_KEY = 'listManagerStarredUsersV2';
            const CURRENT_LIST_KEY = 'listManagerCurrentListV2';
            const THEME_KEY = 'listManagerThemeV2';
            let notificationTimeout;
            let currentModalConfirmAction = null;

            // --- Functions ---

            function showNotification(message, type = 'info', duration = 3000) {
                if (notificationTimeout) clearTimeout(notificationTimeout);
                notificationArea.textContent = message;
                notificationArea.className = ''; // Reset classes
                notificationArea.classList.add(type, 'show');
                notificationTimeout = setTimeout(() => {
                    notificationArea.classList.remove('show');
                }, duration);
            }

            function showModal(message, onConfirm) {
                modalMessage.textContent = message;
                currentModalConfirmAction = onConfirm; // Store the action to run on confirm
                confirmationModal.classList.add('show');
            }

            function hideModal() {
                confirmationModal.classList.remove('show');
                currentModalConfirmAction = null; // Clear the stored action
            }

            function sanitizeUsernameForId(username) {
                // Replace common invalid characters with hyphen, keep letters, numbers, _, -
                return username.replace(/[^a-zA-Z0-9_-]/g, '-');
            }

            function renderList(usernames) {
                userListEl.innerHTML = ''; // Clear existing list
                if (!usernames || usernames.length === 0) {
                    // CSS :empty selector handles the placeholder text
                } else {
                    usernames.forEach(username => {
                        if (!username || !username.trim()) return; // Skip empty/whitespace-only
                        const trimmedUsername = username.trim();
                        // Make ID safe but keep original username for display/link/data
                        const idSafeUsername = `user-${sanitizeUsernameForId(trimmedUsername)}`;
                        const li = document.createElement('li');
                        li.innerHTML = `
                            <input type="checkbox" id="${idSafeUsername}" data-username="${trimmedUsername}">
                            <button class="star-btn" data-username="${trimmedUsername}" title="Star/Unstar">
                                <svg><use href="#icon-star-outline"/></svg>
                            </button>
                            <label for="${idSafeUsername}"><a href="https://www.instagram.com/${trimmedUsername}" target="_blank">${trimmedUsername}</a></label>
                        `;
                        userListEl.appendChild(li);
                    });
                }
                // Load state *after* rendering the new list structure
                loadState();
                // Update stats based on the freshly loaded state
                updateStatsAndSave();
                // Apply filter if any text exists
                 applyFilter();
            }


            function getCurrentUsernames() {
                return Array.from(userListEl.querySelectorAll('li input[type="checkbox"]')) // Ensure we only select list items
                            .map(cb => cb.dataset.username);
            }

            function getCheckedUsernames() { // Only checked AND non-starred
                return Array.from(userListEl.querySelectorAll('li.checked-item:not(.starred-item) input[type="checkbox"]'))
                            .map(cb => cb.dataset.username);
            }

            function getStarredUsernames() {
                return Array.from(userListEl.querySelectorAll('li.starred-item .star-btn'))
                            .map(btn => btn.dataset.username);
            }

            // Gets the full state including checked, starred, and UNCHECKED users
            function getFullState() {
               const allUsernames = getCurrentUsernames();
               const checked = Array.from(userListEl.querySelectorAll('li.checked-item input[type="checkbox"]'))
                               .map(cb => cb.dataset.username); // ALL checked items
               const starred = getStarredUsernames();

               const checkedSet = new Set(checked);
               const starredSet = new Set(starred);

               const unchecked = allUsernames.filter(u => !checkedSet.has(u) && !starredSet.has(u));

               return { checked, starred, unchecked }; // Include all three categories
            }


            function updateStatsAndSave() {
                const allListItems = userListEl.querySelectorAll('li');
                const checkedItems = userListEl.querySelectorAll('li.checked-item');
                const starredItems = userListEl.querySelectorAll('li.starred-item');

                const totalCount = allListItems.length;
                const checkedCount = checkedItems.length; // Count all visually checked
                const starredCount = starredItems.length;

                // Calculate completion percentage based only on non-starred items
                const relevantTotal = totalCount - starredCount;
                const relevantChecked = Array.from(checkedItems).filter(li => !li.classList.contains('starred-item')).length;
                // Handle division by zero and case where all are starred (if all starred are checked, it's 100% complete relevantly)
                const percentage = relevantTotal > 0 ? (relevantChecked / relevantTotal * 100) : (totalCount > 0 && relevantTotal === 0 ? 100 : 0);

                totalUserCountEl.textContent = totalCount;
                checkedUserCountEl.textContent = checkedCount;
                starredUserCountEl.textContent = starredCount;
                completionPercentageEl.textContent = percentage.toFixed(1);

                // Save separate lists for basic restore and starred state
                localStorage.setItem(CHECKED_USERS_KEY, getCheckedUsernames().join(',')); // Only non-starred checked
                localStorage.setItem(STARRED_USERS_KEY, getStarredUsernames().join(','));
                localStorage.setItem(CURRENT_LIST_KEY, getCurrentUsernames().join(',')); // Always save the current list structure
            }

            // Applies state based on provided arrays/sets
             function applyState(checkedUsernames, starredUsernames) {
                 const checkedSet = new Set(checkedUsernames);
                 const starredSet = new Set(starredUsernames);

                 userListEl.querySelectorAll('li').forEach(li => {
                     const checkbox = li.querySelector('input[type="checkbox"]');
                     const starBtn = li.querySelector('.star-btn');
                     const starSvgUse = starBtn ? starBtn.querySelector('use') : null;
                     const username = checkbox ? checkbox.dataset.username : null;

                     if (username) {
                         const isStarred = starredSet.has(username);
                         // Check if it should be checked: EITHER it's in the checked list OR it's starred
                         const isChecked = checkedSet.has(username) || isStarred;

                         checkbox.checked = isChecked;
                         li.classList.toggle('checked-item', isChecked);

                         li.classList.toggle('starred-item', isStarred);
                         if(starSvgUse) {
                              starSvgUse.setAttribute('href', isStarred ? '#icon-star-filled' : '#icon-star-outline');
                         }
                     }
                 });
                 // Update display stats immediately after applying state
                 // This doesn't re-save to localStorage, avoiding loops during load
                const allListItems = userListEl.querySelectorAll('li');
                const checkedItems = userListEl.querySelectorAll('li.checked-item');
                const starredItems = userListEl.querySelectorAll('li.starred-item');
                const totalCount = allListItems.length;
                const checkedCount = checkedItems.length;
                const starredCount = starredItems.length;
                const relevantTotal = totalCount - starredCount;
                const relevantChecked = Array.from(checkedItems).filter(li => !li.classList.contains('starred-item')).length;
                const percentage = relevantTotal > 0 ? (relevantChecked / relevantTotal * 100) : (totalCount > 0 && relevantTotal === 0 ? 100 : 0);

                totalUserCountEl.textContent = totalCount;
                checkedUserCountEl.textContent = checkedCount;
                starredUserCountEl.textContent = starredCount;
                completionPercentageEl.textContent = percentage.toFixed(1);
             }

             // Loads state from localStorage
             function loadState() {
                 const savedChecked = (localStorage.getItem(CHECKED_USERS_KEY) || '').split(',').filter(Boolean);
                 const savedStarred = (localStorage.getItem(STARRED_USERS_KEY) || '').split(',').filter(Boolean);
                 applyState(savedChecked, savedStarred);
             }


            function handleItemClick(event) {
                const target = event.target;
                const starBtn = target.closest('.star-btn'); // Check if click is on star or its SVG
                const checkbox = target.matches('input[type="checkbox"]') ? target : null; // Direct click on checkbox
                const label = target.closest('label'); // Check if click is on label or its link
                const listItem = target.closest('li');

                if (!listItem) return;

                const currentCheckbox = listItem.querySelector('input[type="checkbox"]');
                const currentStarBtn = listItem.querySelector('.star-btn');
                const starSvgUse = currentStarBtn ? currentStarBtn.querySelector('use') : null;
                const username = currentCheckbox?.dataset.username;

                if (!username) return;

                let stateChanged = false;

                // Star button click
                if (starBtn) {
                     const isCurrentlyStarred = listItem.classList.toggle('starred-item');
                     if(starSvgUse) {
                         starSvgUse.setAttribute('href', isCurrentlyStarred ? '#icon-star-filled' : '#icon-star-outline');
                     }
                     // If starring, ensure it's also checked; if unstarring, leave check state as is.
                     if (isCurrentlyStarred) {
                         currentCheckbox.checked = true;
                         listItem.classList.add('checked-item');
                     }
                     stateChanged = true;
                }
                // Checkbox click (directly)
                else if (checkbox) {
                    // Prevent unchecking if it's starred
                    if (listItem.classList.contains('starred-item') && !checkbox.checked) {
                        checkbox.checked = true; // Force it back on
                        showNotification("Starred items cannot be unchecked directly. Unstar first.", "info");
                        // Do not set stateChanged = true here, as no *persistent* state changed
                    } else {
                       listItem.classList.toggle('checked-item', checkbox.checked);
                       stateChanged = true;
                    }
                }
                 // Label click
                 else if (label && currentCheckbox) {
                     // Simulate the state *after* the click
                     const futureCheckedState = !currentCheckbox.checked;
                     if (listItem.classList.contains('starred-item') && !futureCheckedState) {
                         // Intending to uncheck a starred item via label - prevent it
                          showNotification("Starred items cannot be unchecked directly. Unstar first.", "info");
                         // We DON'T toggle the class or set stateChanged = true
                     } else {
                         // Allow toggling check state via label for non-starred items
                         // Checkbox state will toggle naturally due to label 'for' attribute
                         // We just need to update the class based on the *new* state
                         listItem.classList.toggle('checked-item', futureCheckedState);
                         stateChanged = true;
                     }
                 }

                if (stateChanged) {
                     // Update stats and save the new state
                     updateStatsAndSave();
                }
            }

            function copyCheckedListAction() {
                const usernames = getCheckedUsernames(); // Gets only checked, non-starred
                if (usernames.length === 0) {
                    showNotification('No checked (and non-starred) users to copy.', 'info');
                    return;
                }
                checkedListOutput.value = usernames.join(',');
                navigator.clipboard.writeText(checkedListOutput.value).then(() => {
                    showNotification('Checked usernames copied to clipboard!', 'success');
                }).catch(err => {
                    console.error('Clipboard copy failed: ', err);
                    showNotification('Could not copy automatically. Please copy from text area.', 'error');
                    checkedListOutput.select(); // Select for manual copy
                });
            }

            function restoreCheckedListAction() {
                const listToRestore = restoreCheckedListInput.value;
                if (!listToRestore.trim()) {
                    showNotification('Paste a comma-separated list first.', 'error');
                    return;
                }
                const usernamesToRestore = new Set(
                    listToRestore.split(',').map(name => name.trim()).filter(Boolean)
                );
                const currentStarredUsernames = getStarredUsernames(); // Keep existing starred users

                // Apply checked status from the list, keep starred status
                applyState(Array.from(usernamesToRestore), currentStarredUsernames);
                updateStatsAndSave(); // Save the combined state

                showNotification(`Restored checked state for ${usernamesToRestore.size} users found. Starred items remain starred.`, 'success');
                restoreCheckedListInput.value = '';
            }

            function exportFullStateAction() {
                const state = getFullState(); // Includes checked, starred, unchecked
                const stateString = JSON.stringify(state, null, 2);
                fullStateOutput.value = stateString;
                navigator.clipboard.writeText(stateString).then(() => {
                     showNotification('Full state (JSON) copied to clipboard!', 'success');
                 }).catch(err => {
                     console.error('Clipboard copy failed: ', err);
                     showNotification('Could not copy state automatically. Please copy from text area.', 'error');
                     fullStateOutput.select();
                 });
            }

            function importFullStateAction() {
                 const stateString = fullStateOutput.value;
                 if (!stateString.trim()) {
                    showNotification('Paste the exported state data (JSON) first.', 'error');
                    return;
                 }
                 try {
                    const state = JSON.parse(stateString);
                    // Check for required arrays (allow missing 'unchecked')
                    if (!state || typeof state !== 'object' || !Array.isArray(state.checked) || !Array.isArray(state.starred)) {
                         throw new Error("Invalid state format. Missing 'checked' or 'starred' array.");
                    }
                    // Apply the checked and starred arrays from the JSON to the *current* list
                    applyState(state.checked, state.starred);
                    updateStatsAndSave(); // Save the newly applied state

                    showNotification(`Imported full state (${state.checked.length} checked, ${state.starred.length} starred).`, 'success');
                    fullStateOutput.value = ''; // Clear input
                 } catch (error) {
                    console.error("Error parsing state JSON:", error);
                    showNotification(`Error importing state: ${error.message}. Ensure data is valid JSON.`, 'error');
                 }
            }


            function importNewListAction() {
                 const listToImport = importListInput.value;
                 const usernames = listToImport.split(',').map(name => name.trim()).filter(Boolean);
                 if (usernames.length === 0) {
                     showNotification('No valid usernames found in the import list.', 'error');
                     return;
                 }

                 showModal(`Replace the current list with ${usernames.length} users and clear current state?`, () => {
                     localStorage.removeItem(CHECKED_USERS_KEY);
                     localStorage.removeItem(STARRED_USERS_KEY);
                     renderList(usernames); // Renders new list AND calls loadState (which finds nothing) + updateStatsAndSave
                     localStorage.setItem(CURRENT_LIST_KEY, usernames.join(',')); // Save the new list structure
                     importListInput.value = '';
                     filterInput.value = ''; // Clear filter as well
                     showNotification(`Imported ${usernames.length} users successfully.`, 'success');
                     hideModal();
                 });
            }

            function clearAllAction() {
                 showModal("Clear the current list and all checked/starred statuses? This cannot be undone.", () => {
                     localStorage.removeItem(CHECKED_USERS_KEY);
                     localStorage.removeItem(STARRED_USERS_KEY);
                     localStorage.removeItem(CURRENT_LIST_KEY);
                     renderList([]); // Render an empty list
                     filterInput.value = ''; // Clear filter
                     // updateStatsAndSave is called inside renderList
                     showNotification("List and state cleared.", "info");
                     hideModal();
                 });
            }

            function toggleDarkModeAction() {
                body.classList.toggle('dark-mode');
                localStorage.setItem(THEME_KEY, body.classList.contains('dark-mode') ? 'dark' : 'light');
            }

            function applySavedTheme() {
                 const savedTheme = localStorage.getItem(THEME_KEY);
                 // Default to dark if no preference saved or if saved is 'dark'
                 if (savedTheme === 'light') {
                     body.classList.remove('dark-mode');
                 } else {
                     body.classList.add('dark-mode');
                 }
             }

             function applyFilter() {
                const filterText = filterInput.value.toLowerCase().trim();
                let visibleCount = 0;
                userListEl.querySelectorAll('li').forEach(li => {
                    const usernameLink = li.querySelector('a');
                    const username = usernameLink ? usernameLink.textContent.toLowerCase() : '';
                    const shouldShow = filterText === '' || username.includes(filterText);
                    li.classList.toggle('hidden-by-filter', !shouldShow);
                    if (shouldShow) {
                        visibleCount++;
                    }
                });
                 // Optional: Add feedback if filter returns no results?
                 // Maybe update stats to show "X matching filter" ? (Requires more complex stat update)
             }

            // --- Initialization ---
            applySavedTheme(); // Set theme first

            const savedList = localStorage.getItem(CURRENT_LIST_KEY);
            // Render list (saved or empty), which then calls loadState and updateStatsAndSave
            renderList(savedList ? savedList.split(',') : []);

            // Attach listeners
            userListEl.addEventListener('click', handleItemClick); // Use delegation
            copyCheckedListBtn.addEventListener('click', copyCheckedListAction);
            restoreCheckedListBtn.addEventListener('click', restoreCheckedListAction);
            importListBtn.addEventListener('click', importNewListAction); // Uses modal
            clearAllBtn.addEventListener('click', clearAllAction); // Uses modal
            darkModeToggle.addEventListener('click', toggleDarkModeAction);
            exportFullStateBtn.addEventListener('click', exportFullStateAction);
            importFullStateBtn.addEventListener('click', importFullStateAction);
            filterInput.addEventListener('input', applyFilter); // Filter as user types

            // Modal button listeners
            modalConfirmBtn.addEventListener('click', () => {
                if (currentModalConfirmAction) {
                    currentModalConfirmAction(); // Execute the stored confirm action
                }
                // Confirmation action should hide modal on success
            });
            modalCancelBtn.addEventListener('click', hideModal);
            confirmationModal.addEventListener('click', (event) => { // Click on overlay closes modal
                 if (event.target === confirmationModal) {
                    hideModal();
                 }
            });

        });
    </script>

</body>
</html>
